#include <iostream.h> #include<ctype.h> #include <stdlib.h> #include <conio.h> using namespace std; struct node { 	int data; 	node *left; 	node *right; 	int height; }; typedef struct node *nodeptr; class BinarTree { 	public: void insert(int,nodeptr &); void del(int, nodeptr &); int deletemin(nodeptr &); void find(int,nodeptr &); nodeptr findmin(nodeptr); nodeptr findmax(nodeptr); void makeempty(nodeptr &); void copy(nodeptr &,nodeptr &); nodeptr nodecopy(nodeptr &); void preorder(nodeptr); void inorder(nodeptr); void postorder(nodeptr); int bsheight(nodeptr); nodeptr srl(nodeptr &); nodeptr drl(nodeptr &); nodeptr srr(nodeptr &); nodeptr drr(nodeptr &); int max(int,int); int nonodes(nodeptr); }; void BinarTree::insert(int x,nodeptr &p) { 	if (p == NULL) 	{ p = new node; p->data = x; p->left=NULL; p->right = NULL; p->height=0; if (p==NULL) { 	cout<<"Out of Space\n"<<endl; } 	} 	else 	{ if (x<p->data) { 	insert(x,p->left); 	if ((bsheight(p->left) - bsheight(p->right))==2) 	{ if (x < p->left->data) { 	p=srl(p); } else { 	p = drl(p); } 	} } else if (x>p->data) { 	insert(x,p->right); 	if ((bsheight(p->right) - bsheight(p->left))==2) 	{ if (x > p->right->data) { 	p=srr(p); } else { 	p = drr(p); } 	} } else { 	cout<<"Элемет существует\n"<<endl; } } int m,n,d; m=bsheight(p->left); n=bsheight(p->right); d=max(m,n); p->height = d + 1; } nodeptr BinarTree::findmin(nodeptr p) { 	if (p==NULL) 	{ cout<<"В дереве нет элементов\n"<<endl; return p; 	} 	else 	{ while(p->left !=NULL) { 	p=p->left; 	//return p; } return p; 	} } nodeptr BinarTree::findmax(nodeptr p) { 	if (p==NULL) 	{ cout<<"В дереве нет элементов\n"<<endl; return p; 	} 	else 	{ while(p->right !=NULL) { 	p=p->right; 	//return p; } return p; 	} } void BinarTree::find(int x,nodeptr &p) { 	if (p==NULL) 	{ cout<<"Простите, но такого элемента нет\n"<<endl; 	} 	else 	{ if (x < p->data) { 	find(x,p->left); } else { 	if (x>p->data) 	{ find(x,p->right); 	} 	else 	{ cout<<"Элемент, который вы искали есть в дереве!\n"<<endl; 	} } 	} } void BinarTree::copy(nodeptr &p,nodeptr &p1) { 	makeempty(p1); 	p1 = nodecopy(p); } void BinarTree::makeempty(nodeptr &p) { 	nodeptr d; 	if (p != NULL) 	{ makeempty(p->left); makeempty(p->right); d=p; free(d); p=NULL; 	} } nodeptr BinarTree::nodecopy(nodeptr &p) { 	nodeptr temp; 	if (p==NULL) 	{ return p; 	} 	else 	{ temp = new node; temp->data = p->data; temp->left = nodecopy(p->left); temp->right = nodecopy(p->right); return temp; 	} } void BinarTree::del(int x,nodeptr &p) { 	nodeptr d; 	if (p==NULL) 	{ cout<<"Простите, но такого элемента нет\n"<<endl; 	} 	else if ( x < p->data) 	{ del(x,p->left); 	} 	else if (x > p->data) 	{ del(x,p->right); 	} 	else if ((p->left == NULL) && (p->right == NULL)) 	{ d=p; free(d); p=NULL; cou
